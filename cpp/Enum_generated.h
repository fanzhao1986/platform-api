// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUM_COM_REACTIVEMARKETS_PAPI_H_
#define FLATBUFFERS_GENERATED_ENUM_COM_REACTIVEMARKETS_PAPI_H_

#include "flatbuffers/flatbuffers.h"

namespace com {
namespace reactivemarkets {
namespace papi {

enum FeedType {
  FeedType_Default = 0,
  FeedType_Trade = 1,
  FeedType_MIN = FeedType_Default,
  FeedType_MAX = FeedType_Trade
};

inline const FeedType (&EnumValuesFeedType())[2] {
  static const FeedType values[] = {
    FeedType_Default,
    FeedType_Trade
  };
  return values;
}

inline const char * const *EnumNamesFeedType() {
  static const char * const names[3] = {
    "Default",
    "Trade",
    nullptr
  };
  return names;
}

inline const char *EnumNameFeedType(FeedType e) {
  if (flatbuffers::IsOutRange(e, FeedType_Default, FeedType_Trade)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFeedType()[index];
}

enum Side {
  Side_Sell = -1,
  Side_None = 0,
  Side_Buy = 1,
  Side_MIN = Side_Sell,
  Side_MAX = Side_Buy
};

inline const Side (&EnumValuesSide())[3] {
  static const Side values[] = {
    Side_Sell,
    Side_None,
    Side_Buy
  };
  return values;
}

inline const char * const *EnumNamesSide() {
  static const char * const names[4] = {
    "Sell",
    "None",
    "Buy",
    nullptr
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  if (flatbuffers::IsOutRange(e, Side_Sell, Side_Buy)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(Side_Sell);
  return EnumNamesSide()[index];
}

enum SubReqType {
  SubReqType_Subscribe = 1,
  SubReqType_Unsubscribe = 2,
  SubReqType_MIN = SubReqType_Subscribe,
  SubReqType_MAX = SubReqType_Unsubscribe
};

inline const SubReqType (&EnumValuesSubReqType())[2] {
  static const SubReqType values[] = {
    SubReqType_Subscribe,
    SubReqType_Unsubscribe
  };
  return values;
}

inline const char * const *EnumNamesSubReqType() {
  static const char * const names[3] = {
    "Subscribe",
    "Unsubscribe",
    nullptr
  };
  return names;
}

inline const char *EnumNameSubReqType(SubReqType e) {
  if (flatbuffers::IsOutRange(e, SubReqType_Subscribe, SubReqType_Unsubscribe)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(SubReqType_Subscribe);
  return EnumNamesSubReqType()[index];
}

}  // namespace papi
}  // namespace reactivemarkets
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_ENUM_COM_REACTIVEMARKETS_PAPI_H_
